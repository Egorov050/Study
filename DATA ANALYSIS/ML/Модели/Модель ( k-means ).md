Прикол, `knn` может использоваться не только для классификации и  регрессии но и для кластеризации. 

K-means лучше работает с шарообразными структурами данных. 
В отличие от `DBSCAN` , в `k-means` мы должны указать сколько кластеров будем искать. Как выбрать оптимальное количество кластеров мы рассмотрим чуть позже. 

*Как работает алгоритм хорошо описано здесь : https://www.youtube.com/watch?v=EHZJMz6zyFE&t=453s*

Перед тем, как тренировать модель, мы должны провести `некоторые манипуляции` с данными, а именно : 
1)  Удалить выбросы [[Удаление выбросов ( LocalOutlierFactor )]]
2) Подготовить данные [[Подготовка данных]], в том числе и масштабировать их
3) Обработать категориальные данные 
*( База )*

Далее, `инициализируем и тренируем` нашу модель : 

```python 
from sklearn.cluster import KMeans

k = 3
kmeans = KMeans(n_clusters=k, random_state=42)
data_clean['Cluster'] = kmeans.fit_predict(data_clean)
```


Далее, можем визуализировать данные : 

```python

fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

ax.scatter(data_clean['Recency'], data_clean['Monetary'], data_clean['Frequency'], c=data_clean['Cluster'], cmap='viridis')
ax.set_xlabel('Feature1')
ax.set_ylabel('Feature2')
ax.set_zlabel('Feature3')
plt.title('K-means Clustering')
plt.show()

```

И получить вот такое : 
<img width="505" alt="Screenshot 2024-07-04 at 18 01 07" src="https://github.com/Egorov050/Study/assets/115251460/47c31a1b-d047-4a9f-b275-e084b842a326">

Теперь самое интересное, как нам выбрать количество кластеров.

Самое простое, это взглянуть на данные и оценочкой глаза самому подобрать количество кластеров. 

*Но очевидно это не лучший способ* Поэтому есть два вспомогательных инструмента, как правильно подобрать оптимальное количество кластеро. Это `Elbow method (метод локтя)` и `silhouette_score`

Рассмотри более подробно. 

<h3>Elbow method (метод локтя)</h3>
Основаная идея метода локтя заключается в следующем. Мы выбираем предположительное `количество кластеров` ( загоняем их в массив ) и для каждого числа кластеров, мы тренируем нашу модель и высчитываем `инерцию ( inertia )`. Это 
метрика метрика представляет `собой сумму квадратов расстояний между точками и центройдами их кластеров`.  Напишем код, как это сделать и заодно построим график : 

```python 
inertias = []


K_range = range(1, 10)
for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(data_clean)
    inertias.append(kmeans.inertia_)


plt.figure(figsize=(8, 6))
plt.plot(K_range, inertias, marker='o')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.title('Elbow Method for Optimal k')
plt.show()
```

Получим вот такой график : 

<img width="648" alt="Screenshot 2024-07-04 at 18 27 16" src="https://github.com/Egorov050/Study/assets/115251460/6e71e341-efeb-4ec5-adfb-02b4c0bc2829">

Смотрим на те места, где `скорость` функции значительно `уменьшается`. В нашем случае, это точки начиная от 3 до 5. Но вопрос, как нам выбрать один кластер из массива [ 3:5 ] ? Тут на помощь приходит  средний силуэтный коэффициент ( silhouette score ) 
<h3>Silhouette score ( средний силуэтный коэффициент )</h3>
Метрика `silhouette score (средний силуэтный коэффициент)` используется для оценки качества кластеризации. Она измеряет, `насколько хорошо каждая точка данных размещена внутри своего кластера по сравнению с другими кластерами`. Silhouette score может принимать значения от -1 до 1, где:
- Значение близкое к 1 означает, что точки хорошо кластеризованы.
- Значение близкое к 0 означает, что точки находятся на границе между кластерами.
- Значение близкое к -1 означает, что точки, вероятно, помещены в неправильный кластер.
### Принцип работы silhouette score

Для каждой точки данных рассчитываются два значения:

1. **Среднее внутрикластерное расстояние (a)**: среднее расстояние от данной точки до всех других точек в том же кластере.
2. **Среднее межкластерное расстояние (b)**: среднее расстояние от данной точки до всех точек в ближайшем (самом похожем) кластере, к которому данная точка не принадлежит.

Silhouette score для каждой точки определяется как: s=b−amax⁡(a,b)s = \frac{b - a}{\max(a, b)}s=max(a,b)b−a​

Где:

- aaa — среднее расстояние до точек своего кластера.
- bbb — среднее расстояние до точек ближайшего другого кластера.

Среднее значение silhouette score по всем точкам дает общую оценку качества кластеризации.



