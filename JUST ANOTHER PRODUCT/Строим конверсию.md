Прежде чем работать с конверсией, очевидно нужно прочистить датасет...подготовить его в работе...
Когда мы его подготовили, можем приступить :)
<h6>Строим конверсию</h6>
Предположим, что у нас есть датасет с покупками ( например такой https://www.kaggle.com/datasets/yasserh/customer-segmentation-dataset/data )

Для начала мы должны найти `первый стартовый день` когда пользователь `в нашем случае`совершил покупку. Грубо говоря пишем это так : 

```python
first_sale = df.groupby('CustomerID').agg({'date' : 'min'}).reset_index()
first_sale = first_sale.rename(columns=({'date' : 'first'}))
first_sale
```

Получим следующий результат :

|      | CustomerID | first      |
| ---- | ---------- | ---------- |
| 0    | 12346.0    | 2011-01-18 |
| 1    | 12347.0    | 2010-12-07 |
| 2    | 12348.0    | 2010-12-16 |
| 3    | 12349.0    | 2011-11-21 |
| 4    | 12350.0    | 2011-02-02 |
| ...  | ...        | ...        |
| 4367 | 18280.0    | 2011-03-07 |
| 4368 | 18281.0    | 2011-06-12 |
| 4369 | 18282.0    | 2011-08-05 |
| 4370 | 18283.0    | 2011-01-06 |
| 4371 | 18287.0    | 2011-05-22 |
Далее мы должны посчитать периоды для каждого покупателя. Предположим, наш клиент `id 911gt3RS` совершил покупку в Марте, Апреле и Мае. Соотвественно Апрель и Май будут вторым и третьим периодами. Суть заключается в том, что мы смотрим, сколько людей начиная с первого месяца покупки, в последующие месяцы отваливаются , то есть перестают у нас покупать. 

Поэтому следующим этапом мы должны сгруппировать по начальной дате, и периоду : 

```python 
result = df.groupby(['f','q_x']).agg({'InvoiceNo' : 'nunique'}).reset_index()
```

Еще раз. Например 200 человек `первый раз` совершили покупку в `мае`. Для нас это `новая группа`, где `стартовый месяц` это Май. Затем кто то перестает у нас покупать, то есть люди отваливаются. И мы смотрим, кто в какой период еще совершал покупки и затем группируем по стартовому месяцу и этим периодам и считаем количество покупателей. 

Для того, чтобы красиво все визуализировать используя `heatmap` [[Функция ( sns.heatmap(...) )]]  мы должны привести нашу полученную таблицу в формат `pivot table`
Делаем это следующим образом : 

```python 
p = result.pivot(columns='q_x', index='f', values='per')
```

Получаем следующий результат : 

| q_x     | 0     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ------- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 2010-12 | 100.0 | 40.0 | 34.0 | 44.0 | 36.0 | 47.0 | 43.0 | 40.0 | 39.0 | 47.0 | 45.0 | 66.0 | 23.0 |
| 2011-01 | 100.0 | 27.0 | 33.0 | 28.0 | 43.0 | 36.0 | 33.0 | 31.0 | 35.0 | 43.0 | 52.0 | 16.0 | NaN  |
| 2011-02 | 100.0 | 29.0 | 24.0 | 34.0 | 30.0 | 28.0 | 26.0 | 35.0 | 29.0 | 39.0 | 8.0  | NaN  | NaN  |
| 2011-03 | 100.0 | 22.0 | 32.0 | 27.0 | 26.0 | 22.0 | 29.0 | 29.0 | 41.0 | 9.0  | NaN  | NaN  | NaN  |
| 2011-04 | 100.0 | 28.0 | 24.0 | 20.0 | 22.0 | 23.0 | 24.0 | 31.0 | 8.0  | NaN  | NaN  | NaN  | NaN  |
| 2011-05 | 100.0 | 25.0 | 17.0 | 19.0 | 25.0 | 24.0 | 31.0 | 10.0 | NaN  | NaN  | NaN  | NaN  | NaN  |
| 2011-06 | 100.0 | 24.0 | 19.0 | 31.0 | 27.0 | 43.0 | 10.0 | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
| 2011-07 | 100.0 | 21.0 | 25.0 | 24.0 | 36.0 | 11.0 | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
| 2011-08 | 100.0 | 29.0 | 34.0 | 33.0 | 13.0 | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
| 2011-09 | 100.0 | 34.0 | 41.0 | 11.0 | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
| 2011-10 | 100.0 | 37.0 | 13.0 | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
| 2011-11 | 100.0 | 13.0 | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |
| 2011-12 | 100.0 | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |

Далее просто пишем : 

```python 
sns.heatmap(p)
```

Также, стоит отметить что мы должны указать `процент`, ведь конверсия считается в процентах :)

