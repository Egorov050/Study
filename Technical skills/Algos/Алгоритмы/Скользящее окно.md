Скользящее **окно** — это эффективный метод, используемый для решения задач, связанных с массивами или строками, где нам нужно найти поддиапазон, который удовлетворяет определенному условию. **Вместо того, чтобы каждый раз пересчитывать весь диапазон с нуля, мы скользим окном по массиву/строке и обновляем решение пошагово.**

По сути, он также состоит из двух указателей. И самое главное нам также понять, когда двигать один указатель, а когда другой. 

Рассмотрим задачу :  https://contest.yandex.ru/contest/27794/problems/F/?success=138148229#30404/2021_06_01/KKpQc8mKVb

> Понимаем, что нас интересует минимальная цена.Поэтому мы можем отсортировать массив с информацией о кондиционерах по возрастанию, также отсортировать классы по возрастанию и уже в таком порядке проверять. Ограничения будут также для верхнего указателя : до размера массива классов. Для нижнего : до размера массива кондиц. Получаем следующий код : 

```python

n = int(input())
nums = list(map(int, input().split()))
data = []

s= 0

m = int(input())
for i in range(m) : 
    power, price = map(int, input().split())
    data.append([power, price])


up, down = 0,0 
nums.sort()
data.sort(key = lambda x : x[1])

while up < len(nums) and down < len(data) : 

    if nums[up] <= data[down][0] : 
        s+= data[down][1]
        up+=1 
    else : 
        down+=1

print(s)

```



Другая задача это поиск самой длинной последовательности : https://leetcode.com/problems/longest-substring-without-repeating-characters/description/

Также задаем два указателя и формируем окно. В качестве вещи, которая будет выпиздюливать те значения, которые уже есть в массиве, будет использоваться **deque**. То есть мы создаем окно. В качестве окна будет выступать deque. Мы будем класть в него элемент. Если мы видим, что элемент уже есть в массиве -> значит у нас начинается новая строка -> и до тех пор пока повторяющийся элемент в массиве мы должны удалять значения. При этом мы должны обновлять минимальную длину нашей последовательности. 

Код выглядит следующим образом : 

```python 

from collections import deque
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        from collections import deque
 
        n = list(s)
        check = deque()
        right = 0
        ml = 0


        while right < len(n) : 
            while n[right] in check : 
                check.popleft()
                ml = max(ml, len(check))
            check.append(n[right])
            ml = max(ml, len(check))
            right+=1
            
        return(ml)   

```


Аналогичная задача - https://leetcode.com/problems/minimum-size-subarray-sum/description/
Только тут чтобы не тратить место, мы задаем изначально сумму, которую мы будем увеличивать и убирать пофакту прохождения по массиву. То есть у нас s будет представленна как sum(deque).

> Мы добавляем след элемент массива к сумме. Соответственно,  до тех пор пока у меня сумма больше чем target, мы должны вычитать последние элементы окна -> то есть `left` и смотреть, не появилось ли у нас новой минимальной длины. 

> в противном случае мы должны просто двигать right+=


https://contest.yandex.ru/contest/27794/problems/B/


### Распространенные случаи использования [:](https://ajay-dhangar.github.io/algo/docs/extra/Sliding-Window/sliding-window#common-use-cases "Прямая ссылка на общие варианты использования:")

- Нахождение максимальной/минимальной суммы подмассива размера k .
- Поиск самой длинной подстроки с k различными символами .
- Нахождение анаграммы одной строки внутри другой строки .
- Нахождение подмассива с суммой, равной целевому значению .








