
Подсчет отрезка с максмальной суммой также основывается на префиксных суммах : https://official.contest.yandex.ru/contest/59083/problems/B/. Принцип действия : 

```python

Идём по массиву с индекса 1:

- Если `current_sum + arr[i] < arr[i]`, то начинаем **новый отрезок** с `i`
    
- Иначе — расширяем текущий отрезок
    
- Если `current_sum > max_sum`, обновляем `max_sum`, а также `start`, `end`

```


Решение задачи : [238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/) также основывается на префиксных суммах : 

```python

class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        leftPr = [1] * len(nums)
        rightPr = [1] * len(nums)
        for i in range(1, len(nums)) : 
            leftPr[i] = leftPr[i-1] * nums[i-1]
        for i in range(len(nums)-2,-1,-1) : 
            rightPr[i] = rightPr[i+1] * nums[i+1]
        return [leftPr[i] * rightPr[i] for i in range(len(leftPr))]

```


Реализация префиксной суммы : 

```python

n = [1,2,3,4,5,6,7,8]
prefix = [0] * (len(n)+1)

for i in range(1, len(n)+1) : 
    prefix[i] = prefix[i-1] + n[i-1]
    

```

Стоит обратить внимание, что : 
- длина префиксного массива на 1 больше чем изначальный массив
- начинаем от 1 до len(n) + 1 
- первый префикс всегда будет нулем 



Префиксная сумма для подсчета нулей : 

```python

n = [1,0,3,4,0,6,7,8]
prefix = [0] * (len(n)+1)
for i in range(1, len(n)+1) : 
    prefix[i] = prefix[i-1] + (1 if n[i-1] == 0 else 0)
    


```



