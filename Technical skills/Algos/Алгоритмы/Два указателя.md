
Можно выделить два вида указателей : 
- которые идут навстречу друг-другу `left, right = 0, len(nums)-1`
- которые идут вместе в одну сторону, формируя скользящее окно `left, right = 0,0`

**Основные сценарии  :**

| Сценарий                             | Тип указателей        | Пример задачи                          |
| ------------------------------------ | --------------------- | -------------------------------------- |
| Поиск пары с суммой = target         | навстречу друг другу  | «Two Sum II» в отсортированном массиве |
| Проверка/удаление дубликатов         | скользящее окно       | «Remove Duplicates from Sorted Array»  |
| Наибольшая сумма подмассива ≤ k      | скользящее окно       | «Subarray Sum ≤ K»                     |
| Проверка палиндрома                  | навстречу друг другу  | «Valid Palindrome»                     |
| Слияние двух отсортированных списков | навстречу друг другу¹ | Merge Two Sorted Lists                 |
| Вращение/реверс строки               | навстречу друг другу  | Reverse String                         |
| Циклический буфер/кольцевой буфер    | скользящее окно       | Sliding Window Maximum                 |
| Определение цикла в связном списке   | быстрый/медленный²    | Floyd’s Cycle Detection                |


Идея решения задач на два указателя / скользящего окна заключается в понимании, при каких условиях и когда мы двигаем тот или иной указатель. 

Для понимания, как нужно мыслить рассмотрим задачу : https://contest.yandex.ru/contest/27794/problems/A/ 

>Глеб обожает шоппинг. Как-то раз он загорелся идеей подобрать себе майку и штаны так, чтобы выглядеть в них максимально стильно. В понимании Глеба стильность одежды тем больше, чем меньше разница в цвете элементов его одежды.
 В наличии имеется N (1 ≤ N ≤ 100 000) маек и M (1 ≤ M ≤ 100 000) штанов, про каждый элемент известен его цвет (целое число от 1 до 10 000 000). Помогите Глебу выбрать одну майку и одни штаны так, чтобы разница в их цвете была как можно меньше. 
 
```
Пример 

Ввод : 
2
3 4
3
1 2 3

Вывод : 
3 3


```

`Как мы начинаем думать?`

>нам нужно найти минимальную разницу между первыми вторым массивом. => так как они разной длины то делаем два ограничения : для первого указателя -> длина первого массива, для второго указателя -> длина второго массива. 


Одежда : 

```python

n = int(input())
n1 = list(map(int, input().split()))

m = int(input())
m1 = list(map(int, input().split()))


up , down = 0,0    
mdiff = max(n1[-1], m1[-1])
a,b = 0,0

while up < len(n1) and down <len(m1) : 
    cdiff = abs(n1[up] - m1[down]) 
    if cdiff < mdiff : 
        a,b = up,down
        mdiff = cdiff
    if n1[up] < m1[down] : 
        up+=1
    else : 
        down+=1
        
print(n1[a], m1[b])        

```




**Простое решение задачи Two Sum**

```python

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]: 
        data = [[i,v] for i,v in enumerate(nums)]
        data.sort(key = lambda x: x[1])

        left, right = 0, (len(nums)-1)
        while left < right : 
            summ = data[left][1] + data[right][1]
            if summ == target : 
                return [data[left][0], data[right][0]]
            if summ > target : 
                right-=1
            else : 
                left+=1


        

        

         

```

### Распространенные случаи использования [:](https://ajay-dhangar.github.io/algo/docs/extra/algorithms/Two-Pointers/two-pointers#common-use-cases "Прямая ссылка на общие варианты использования:")

- Поиск пар в массиве, сумма которых равна целевому значению .
- Переворачивание строки .
- Объединение двух отсортированных массивов .
- Поиск самой длинной подстроки, содержащей не более K различных символов .



![[Screenshot 2025-05-04 at 3.19.20 PM.png]]

идея решения данной задачи заключается в том, что : 
Размер самой крупной группы попарно похожих дел равен минимальному числу дней, за которые можно выполнить все дела: из каждой такой «максимальной» группы в каждый день можно сделать не более одного дела, а все остальные задачи удаётся распределить по этим дням. Таким образом, этот размер сразу даёт и нижнюю, и достижимую верхнюю границу для количества дней.

поэтому код будет вот такой : 

```python

n, k = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
l = 0
ans = 0
for r in range(n):
    while a[r] - a[l] > k:
        l += 1
    ans = max(ans, r - l + 1)
print(ans)


```




![[Pasted image 20250506090607.png]]