Проверить как будет работать на двух числах 

Бин поиск работает корректно только тогда, когда есть хотя бы одно подходящее решение 



- **Если ты ищешь конкретное значение (== x)** — возвращай mid, когда найдёшь его.
    
- **Если ты ищешь границу (первый элемент ≥ x или > x)** — после цикла возвращай left.
    
- **Если ты ищешь последний элемент ≤ x** — после цикла возвращай right.





В реализации бинарного поиска, как у тебя, нужно понимать, что:

- `mid` — это **текущий** индекс, который проверяется в цикле.
    
- `left` — это **нижняя граница** поиска (в том числе — потенциальное место вставки, если элемент не найден).


### ✅ Когда выводить `mid`:

Вывод `mid` актуален, **если элемент найден**. Тогда `mid` — это индекс элемента `k` в списке `nums`.


```python
if nums[mid] == k:     
	print("YES")     
	print(mid)  # выводим индекс найденного элемента     
    break
```



### ✅ Когда выводить `left`:

Вывод `left` нужен, **если элемент не найден**, но ты хочешь узнать:

- **где бы он находился**, если бы ты его вставлял (позиция для вставки, чтобы сохранить порядок);
- или если делаешь что-то вроде поиска **нижней границы (lower bound)**.


После завершения цикла, если элемент не найден, `left` указывает на первую позицию, где **можно вставить `k`, чтобы `nums` остался отсортированным**.


```python
# Если не нашли: 
print("NO") 
print(left)  # позиция, куда можно вставить k
```



Если мы хотим найти первый элемент, который больше чем k, то мы пишем : 

```python
def first_greater_than(arr, K):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] > K:
            right = mid - 1
        else:
            left = mid + 1
    # left указывает на первый > K
    return arr[left] if left < len(arr) else None

```


Если мы хоти последний элемент, который меньше чем k, то мы пишем : 

```python

def last_less_than(arr, K):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] < K:
            left = mid + 1
        else:
            right = mid - 1
    # left указывает на первый ≥ K, значит ответ — это right
    return arr[right] if right >= 0 else None

```



|Что ищем|Условие|Двигаем|Ответ после цикла|
|---|---|---|---|
|**Первый ≥ K (lower_bound)**|`arr[mid] >= K`|`right = mid - 1`|`left`|
|**Первый > K**|`arr[mid] > K`|`right = mid - 1`|`left`|
|**Последний ≤ K**|`arr[mid] <= K`|`left = mid + 1`|`right`|
|**Последний < K**|`arr[mid] < K`|`left = mid + 1`|`right`|

