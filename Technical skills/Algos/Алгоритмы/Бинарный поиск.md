<h4>На что обратить внимание : </h4>
- Бин поиск работает корректно только тогда, когда есть хотя бы одно подходящее решение 
- Проверить как будет работать на двух числах 
- Массив должен быть отсортированный массив, к которому применяется бинарный поиск



Мы можем применять бинпоиск к решению задача : 
- работа с функциями 
- подбор бинпоиском ответов, подходящих условию


<h4>Функция </h4>

Мы можем применять бинпоиск только к монотонной функции. То есть функция : 
- либо **всегда растёт** (например, $f(x)=x2+x$       $f(x) = x^2 + \sqrt{x}$        $f(x)=x2+x​)$
- либо **всегда убывает**,
- либо имеет **однозначную направленность** в нужной части (например, парабола, но ты ищешь только правую ветвь)

| Характеристика   | По целым (`int`)      | По вещественным (`float`)                |
| ---------------- | --------------------- | ---------------------------------------- |
| Остановка        | `left <= right`       | `right - left > ε`                       |
| Точность         | Точное совпадение     | Приближение с заданной точностью         |
| mid              | `(left + right) // 2` | `(left + right) / 2`                     |
| Ответ            | Точное значение (res) | Приближённое значение (left/right)       |
| Проверка условий | `f(mid) >= target`    | `abs(f(mid) - target) < ε` — опционально |

Когда речь идет про функции, то мы не пишем `right = mid - 1` или `left = mid - 1` так как у нас в функции дискретные значения (непрерывные) и это говорит о том что если мы прибавим 1, то мы можем много чего пропустить 


<h4>Иные задачи</h4>

Для бин поиска можно использовать bysect.bysect_right и bysect.bysect_left
Они используются для **вставки элемента в отсортированный список**:

```python
import bisect
        
a = [1, 3, 4, 7]
bisect.bisect_left(a, 4)   # Вернет индекс: 2
bisect.bisect_right(a, 4)  # Вернет индекс: 3
 ```

Эти функции используются, чтобы:
- `bisect_left` — найти **первое подходящее место для вставки** (слева).
- `bisect_right` — найти **место сразу после последнего подходящего** (вправо).

Это удобо использовать в таких задачах, когда мы хотим например узнать, сколько элементов одного массива входит в другой массив. 

Классическая реализация бинпоиска выглядит следующим образом : 

```python

left, right = 0, l[-1]
while left <= right:
    mid = (left + right) // 2
    if mid == 0:
        break
    if c(l, mid) >= b:
        res = mid
        left = mid + 1
    else:
        right = mid - 1

print(res)

# здесь написан бинпоиск для функции (как в первом разделе), при этом тут мы видим, что исключаем нуль так как в в функции "c" проходит деление, а на нуль делить нельзя :) 

```


При классической реализации бинарного поиска, мы можем выводить как `left`, так и `mid`. Также обратим внимание, что бывают задачи, когда мы должны `mid` сохранять в отдельную переменную и выводить именно ее в качестве ответа. 


<h4>Знаки >= и > и в обратную сторону :)  </h4>
**Когда использовать if условие: right = mid (то есть >) :** Если ищем минимальное значение, при котором условие становится истинным, и хотим сдвигать вправо “неподходящие” значения.

Пример :  Найти минимшую длину x, при которой можно порезать доски на k кусков длиной не меньше x.


**Когда использовать if условие: left = mid + 1 (то есть >=) :** Если ищем максимальное значение, при котором условие всё ещё выполняется, и хотим сдвигать влево те значения, при которых условие уже нарушено.

Пример : Найти максимальную длину x, при которой можно получить хотя бы k кусков.


<h4>Когда мы хотим : </h4>

**Первый элемент , который больше ≥ K (lower_bound) :** 

```python

# 1) Первый элемент ≥ K
def first_ge(arr, K):
    left, right = 0, len(arr) - 1
    ans = None
    while left <= right:
        mid = (left + right) // 2
        # если arr[mid] ≥ K, то мы нашли кандидата на первый ≥ K,
        # но он может быть еще левее → сохраняем его и двигаем правую границу влево
        if arr[mid] >= K:
            ans = arr[mid]
            right = mid - 1
        else:
            # иначе arr[mid] < K, значит все слева от mid тоже < K
            # → сдвигаем левую границу вправо
            left = mid + 1
    return ans



```


**Задачи, где используется именно такой шаблон**
- **LeetCode 35. Search Insert Position**
    > Вставить `target` в отсортированный массив, чтобы сохранить упорядоченность (возвращается индекс первого элемента ≥ target).
- **CSES – Movie Festival II**
    > Для каждого фильма находит первый фильм, начинающийся не раньше заданного времени.




**Первое элемент, который  > K (upper_bound)**

```python

# 2) Первый элемент > K
def first_gt(arr, K):
    left, right = 0, len(arr) - 1
    ans = None
    while left <= right:
        mid = (left + right) // 2
        # если arr[mid] > K, это наш кандидат на первый строго > K,
        # но может быть ещё раньше в левой части → сохраняем и двигаем right влево
        if arr[mid] > K:
            ans = arr[mid]
            right = mid - 1
        else:
            # иначе arr[mid] ≤ K, значит он и всё слева не подходят → сдвигаем left вправо
            left = mid + 1
    return ans


```

**Задачи, где нужен строго “больше”**
- **STL upper_bound** (в C++): именно так реализуется в стандартной библиотеке.
- **Поиск первого элемента, превосходящего заданный порог**: нередко встречается на Codeforces, когда нужно быстро вычистить диапазон ≤ K.



**Последний элемент ≤ K**

```python

# 3) Последний элемент ≤ K
def last_le(arr, K):
    left, right = 0, len(arr) - 1
    ans = None
    while left <= right:
        mid = (left + right) // 2
        # если arr[mid] ≤ K, то это кандидат на последний ≤ K,
        # но может быть ещё правее → сохраняем и двигаем левую границу вправо
        if arr[mid] <= K:
            ans = arr[mid]
            left = mid + 1
        else:
            # иначе arr[mid] > K, значит он и все справа от mid > K
            # → сдвигаем правую границу влево
            right = mid - 1
    return ans


```

**Пример задачи**
- **LeetCode 69. Sqrt(x)**
    > Найти наибольшее целое `r` такое, что `r*r <= x` — это последний `r` с квадратом ≤ x.
- когда мы хотим найти максимальное расстояние 



**Последний элемент < K**

```python

# 4) Последний элемент < K
def last_lt(arr, K):
    left, right = 0, len(arr) - 1
    ans = None
    while left <= right:
        mid = (left + right) // 2
        # если arr[mid] < K, это кандидат на последний < K,
        # но может быть ещё правее → сохраняем и двигаем left вправо
        if arr[mid] < K:
            ans = arr[mid]
            left = mid + 1
        else:
            # иначе arr[mid] ≥ K, значит он и всё справа не подходят
            # → сдвигаем правую границу влево
            right = mid - 1
    return ans


```
    



В реализации бинарного поиска, как у тебя, нужно понимать, что:

- `mid` — это **текущий** индекс, который проверяется в цикле.
- `left` — это **нижняя граница** поиска (в том числе — потенциальное место вставки, если элемент не найден).


### ✅ Когда выводить `mid`:

Вывод `mid` актуален, **если элемент найден**. Тогда `mid` — это индекс элемента `k` в списке `nums`.


```python
if nums[mid] == k:     
	print("YES")     
	print(mid)  # выводим индекс найденного элемента     
    break
```


### ✅ Когда выводить `left`:

Вывод `left` нужен, **если элемент не найден**, но ты хочешь узнать:

- **где бы он находился**, если бы ты его вставлял (позиция для вставки, чтобы сохранить порядок);
- или если делаешь что-то вроде поиска **нижней границы (lower bound)**.


После завершения цикла, если элемент не найден, `left` указывает на первую позицию, где **можно вставить `k`, чтобы `nums` остался отсортированным**.


```python
# Если не нашли: 
print("NO") 
print(left)  # позиция, куда можно вставить k
```



<h4>Ситуация: ты используешь бинарный поиск , чтобы найти **минимальное число дней**, за которое выполняется условие `s ≥ X`.</h4>

В таком случае нужно всегда `mid` (наше значение посередине) сохранять в переменную : 

```python

if s >= X:
    res = mid
    right = mid - 1
else:
    left = mid + 1

```


Почему здесь сохраняем `mid` в `res`?
- Мы ищем **наименьшее** значение `mid`, при котором выполняется условие.
- Каждый раз, когда `s >= X`, мы говорим: "Окей, это может быть ответом. Но вдруг есть меньшее значение, которое тоже подойдёт?".

Поэтому :
    - Мы **запоминаем** текущее `mid` как возможный ответ (`res = mid`)
    - И **продолжаем искать слева**, уменьшая `right`.
        
Это **поиск минимума**, удовлетворяющего условию. В таких задачах **всегда нужно сохранять**


<h4>Сразу выводим mid?</h4>

- Это подходит только если ты ищешь **точное совпадение** (`s == X`), и оно **гарантированно есть**.
- Но если таких значений несколько или их может не быть, ты можешь получить неправильный или отсутствующий ответ.


<h4>Запомни простое правило:</h4>

> **Если ты ищешь "минимальное" или "максимальное" значение, при котором условие выполняется, — всегда сохраняй `mid` в `res` и продолжай бинарный поиск.**




https://official.contest.yandex.ru/contest/59089/problems/H/


