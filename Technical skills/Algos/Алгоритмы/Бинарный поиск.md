<h4>На что обратить внимание : </h4>
- Бин поиск работает корректно только тогда, когда есть хотя бы одно подходящее решение 
- Проверить как будет работать на двух числах 
- Массив должен быть отсортированный массив, к которому применяется бинарный поиск



Мы можем применять бинпоиск к решению задача : 
- работа с функциями 
- подбор бинпоиском ответов, подходящих условию


<h4>Функция </h4>

Мы можем применять бинпоиск только к монотонной функции. То есть функция : 
- либо **всегда растёт** (например, $f(x)=x2+x$       $f(x) = x^2 + \sqrt{x}$        $f(x)=x2+x​)$
- либо **всегда убывает**,
- либо имеет **однозначную направленность** в нужной части (например, парабола, но ты ищешь только правую ветвь)

| Характеристика   | По целым (`int`)      | По вещественным (`float`)                |
| ---------------- | --------------------- | ---------------------------------------- |
| Остановка        | `left <= right`       | `right - left > ε`                       |
| Точность         | Точное совпадение     | Приближение с заданной точностью         |
| mid              | `(left + right) // 2` | `(left + right) / 2`                     |
| Ответ            | Точное значение (res) | Приближённое значение (left/right)       |
| Проверка условий | `f(mid) >= target`    | `abs(f(mid) - target) < ε` — опционально |

Когда речь идет про функции, то мы не пишем `right = mid - 1` или `left = mid - 1` так как у нас в функции дискретные значения (непрерывные) и это говорит о том что если мы прибавим 1, то мы можем много чего пропустить 


<h4>Иные задачи</h4>

Для бин поиска можно использовать bysect.bysect_right и bysect.bysect_left
Они используются для **вставки элемента в отсортированный список**:

```python
import bisect
        
a = [1, 3, 4, 7]
bisect.bisect_left(a, 4)   # Вернет индекс: 2
bisect.bisect_right(a, 4)  # Вернет индекс: 3
 ```

Эти функции используются, чтобы:
- `bisect_left` — найти **первое подходящее место для вставки** (слева).
- `bisect_right` — найти **место сразу после последнего подходящего** (вправо).

Это удобо использовать в таких задачах, когда мы хотим например узнать, сколько элементов одного массива входит в другой массив. 

Классическая реализация бинпоиска выглядит следующим образом : 

```python

left, right = 0, l[-1]
while left <= right:
    mid = (left + right) // 2
    if mid == 0:
        break
    if c(l, mid) >= b:
        res = mid
        left = mid + 1
    else:
        right = mid - 1

print(res)

# здесь написан бинпоиск для функции (как в первом разделе), при этом тут мы видим, что исключаем нуль так как в в функции "c" проходит деление, а на нуль делить нельзя :) 

```


При классической реализации бинарного поиска, мы можем выводить как `left`, так и `mid`. Также обратим внимание, что бывают задачи, когда мы должны `mid` сохранять в отдельную переменную и выводить именно ее в качестве ответа. 


<h4>Знаки >= и > </h4>
**Когда использовать if условие: right = mid (то есть >) :** Если ищем минимальное значение, при котором условие становится истинным, и хотим сдвигать вправо “неподходящие” значения.

Пример :  Найти минимшую длину x, при которой можно порезать доски на k кусков длиной не меньше x.


**Когда использовать if условие: left = mid + 1 (то есть >=) :** Если ищем максимальное значение, при котором условие всё ещё выполняется, и хотим сдвигать влево те значения, при которых условие уже нарушено.

Пример : Найти максимальную длину x, при которой можно получить хотя бы k кусков.





В реализации бинарного поиска, как у тебя, нужно понимать, что:

- `mid` — это **текущий** индекс, который проверяется в цикле.
- `left` — это **нижняя граница** поиска (в том числе — потенциальное место вставки, если элемент не найден).


### ✅ Когда выводить `mid`:

Вывод `mid` актуален, **если элемент найден**. Тогда `mid` — это индекс элемента `k` в списке `nums`.


```python
if nums[mid] == k:     
	print("YES")     
	print(mid)  # выводим индекс найденного элемента     
    break
```


### ✅ Когда выводить `left`:

Вывод `left` нужен, **если элемент не найден**, но ты хочешь узнать:

- **где бы он находился**, если бы ты его вставлял (позиция для вставки, чтобы сохранить порядок);
- или если делаешь что-то вроде поиска **нижней границы (lower bound)**.


После завершения цикла, если элемент не найден, `left` указывает на первую позицию, где **можно вставить `k`, чтобы `nums` остался отсортированным**.


```python
# Если не нашли: 
print("NO") 
print(left)  # позиция, куда можно вставить k
```



Если мы хотим найти первый элемент, который больше чем k, то мы пишем : 

```python
def first_greater_than(arr, K):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] > K:
            right = mid - 1
        else:
            left = mid + 1
    # left указывает на первый > K
    return arr[left] if left < len(arr) else None

```


Если мы хоти последний элемент, который меньше чем k, то мы пишем : 

```python

def last_less_than(arr, K):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] < K:
            left = mid + 1
        else:
            right = mid - 1
    # left указывает на первый ≥ K, значит ответ — это right
    return arr[right] if right >= 0 else None

```





|Что ищем|Условие|Двигаем|Ответ после цикла|
|---|---|---|---|
|**Первый ≥ K (lower_bound)**|`arr[mid] >= K`|`right = mid - 1`|`left`|
|**Первый > K**|`arr[mid] > K`|`right = mid - 1`|`left`|
|**Последний ≤ K**|`arr[mid] <= K`|`left = mid + 1`|`right`|
|**Последний < K**|`arr[mid] < K`|`left = mid + 1`|`right`|





        




### Ситуация: ты используешь **бинарный поиск** (binary search), чтобы найти **минимальное число дней**, за которое выполняется условие `s ≥ X`.

В таком случае нужно всегда `mid` (наше значение посередине) сохранять в переменную : 

```python

if s >= X:
    res = mid
    right = mid - 1
else:
    left = mid + 1

```


Почему здесь сохраняем `mid` в `res`?
- Мы ищем **наименьшее** значение `mid`, при котором выполняется условие.
- Каждый раз, когда `s >= X`, мы говорим: "Окей, это может быть ответом. Но вдруг есть меньшее значение, которое тоже подойдёт?".

Поэтому :
    - Мы **запоминаем** текущее `mid` как возможный ответ (`res = mid`)
    - И **продолжаем искать слева**, уменьшая `right`.
        
Это **поиск минимума**, удовлетворяющего условию. В таких задачах **всегда нужно сохранять**


### Сразу выводим mid?

- Это подходит только если ты ищешь **точное совпадение** (`s == X`), и оно **гарантированно есть**.
- Но если таких значений несколько или их может не быть, ты можешь получить неправильный или отсутствующий ответ.


### Запомни простое правило:

> **Если ты ищешь "минимальное" или "максимальное" значение, при котором условие выполняется, — всегда сохраняй `mid` в `res` и продолжай бинарный поиск.**




