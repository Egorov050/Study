Проверить как будет работать на двух числах 

Бин поиск работает корректно только тогда, когда есть хотя бы одно подходящее решение 

Также должен быть отсортированный массив!!! к которому применяется бинарный поиск

Мы можем применять бинпоиск только к мнотонной функции. То есть : 
Функция:

- либо **всегда растёт** (например, $f(x)=x2+x$       $f(x) = x^2 + \sqrt{x}$        $f(x)=x2+x​)$
- либо **всегда убывает**,
- либо имеет **однозначную направленность** в нужной части (например, парабола, но ты ищешь только правую ветвь)


| Характеристика   | По целым (`int`)      | По вещественным (`float`)                |
| ---------------- | --------------------- | ---------------------------------------- |
| Остановка        | `left <= right`       | `right - left > ε`                       |
| Точность         | Точное совпадение     | Приближение с заданной точностью         |
| mid              | `(left + right) // 2` | `(left + right) / 2`                     |
| Ответ            | Точное значение (res) | Приближённое значение (left/right)       |
| Проверка условий | `f(mid) >= target`    | `abs(f(mid) - target) < ε` — опционально |
Когда речь идет про функции, то мы не пишем `right = mid - 1` или `left = mid - 1` так как у нас в функции дискретные значения (не)



- **Если ты ищешь конкретное значение (== x)** — возвращай mid, когда найдёшь его.
- **Если ты ищешь границу (первый элемент ≥ x или > x)** — после цикла возвращай left.
- **Если ты ищешь последний элемент ≤ x** — после цикла возвращай right.





В реализации бинарного поиска, как у тебя, нужно понимать, что:

- `mid` — это **текущий** индекс, который проверяется в цикле.
    
- `left` — это **нижняя граница** поиска (в том числе — потенциальное место вставки, если элемент не найден).


### ✅ Когда выводить `mid`:

Вывод `mid` актуален, **если элемент найден**. Тогда `mid` — это индекс элемента `k` в списке `nums`.


```python
if nums[mid] == k:     
	print("YES")     
	print(mid)  # выводим индекс найденного элемента     
    break
```



### ✅ Когда выводить `left`:

Вывод `left` нужен, **если элемент не найден**, но ты хочешь узнать:

- **где бы он находился**, если бы ты его вставлял (позиция для вставки, чтобы сохранить порядок);
- или если делаешь что-то вроде поиска **нижней границы (lower bound)**.


После завершения цикла, если элемент не найден, `left` указывает на первую позицию, где **можно вставить `k`, чтобы `nums` остался отсортированным**.


```python
# Если не нашли: 
print("NO") 
print(left)  # позиция, куда можно вставить k
```



Если мы хотим найти первый элемент, который больше чем k, то мы пишем : 

```python
def first_greater_than(arr, K):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] > K:
            right = mid - 1
        else:
            left = mid + 1
    # left указывает на первый > K
    return arr[left] if left < len(arr) else None

```


Если мы хоти последний элемент, который меньше чем k, то мы пишем : 

```python

def last_less_than(arr, K):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] < K:
            left = mid + 1
        else:
            right = mid - 1
    # left указывает на первый ≥ K, значит ответ — это right
    return arr[right] if right >= 0 else None

```





|Что ищем|Условие|Двигаем|Ответ после цикла|
|---|---|---|---|
|**Первый ≥ K (lower_bound)**|`arr[mid] >= K`|`right = mid - 1`|`left`|
|**Первый > K**|`arr[mid] > K`|`right = mid - 1`|`left`|
|**Последний ≤ K**|`arr[mid] <= K`|`left = mid + 1`|`right`|
|**Последний < K**|`arr[mid] < K`|`left = mid + 1`|`right`|




Также имеется bysec_right и bysec_left 

Они используются для **вставки элемента в отсортированный список**:
        
```python
import bisect
        
a = [1, 3, 4, 7]
bisect.bisect_left(a, 4)   # Вернет индекс: 2
bisect.bisect_right(a, 4)  # Вернет индекс: 3
 ```
        
2. Эти функции используются, чтобы:
    - `bisect_left` — найти **первое подходящее место для вставки** (слева).
    - `bisect_right` — найти **место сразу после последнего подходящего** (вправо).
        




### Ситуация: ты используешь **бинарный поиск** (binary search), чтобы найти **минимальное число дней**, за которое выполняется условие `s ≥ X`.

В таком случае нужно всегда `mid` (наше значение посередине) сохранять в переменную : 

```python

if s >= X:
    res = mid
    right = mid - 1
else:
    left = mid + 1

```


Почему здесь сохраняем `mid` в `res`?
- Мы ищем **наименьшее** значение `mid`, при котором выполняется условие.
- Каждый раз, когда `s >= X`, мы говорим: "Окей, это может быть ответом. Но вдруг есть меньшее значение, которое тоже подойдёт?".

Поэтому :
    - Мы **запоминаем** текущее `mid` как возможный ответ (`res = mid`)
    - И **продолжаем искать слева**, уменьшая `right`.
        
Это **поиск минимума**, удовлетворяющего условию. В таких задачах **всегда нужно сохранять**


### Сразу выводим mid?

- Это подходит только если ты ищешь **точное совпадение** (`s == X`), и оно **гарантированно есть**.
- Но если таких значений несколько или их может не быть, ты можешь получить неправильный или отсутствующий ответ.


### Запомни простое правило:

> **Если ты ищешь "минимальное" или "максимальное" значение, при котором условие выполняется, — всегда сохраняй `mid` в `res` и продолжай бинарный поиск.**




